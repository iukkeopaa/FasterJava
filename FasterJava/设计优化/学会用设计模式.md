## 单例模式的好处

1. 对于频繁使用的对象，可以省去创建对象所花费的时间，特别对于重量级的对象
2. 由于new操作的次数越少，对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间

## 代理模式

在现实中，使用代理的情况很普遍，而且原因也很多。比如，当事人因为某些隐私不方便出面，或者当事人不具备某些相关的专业技能，而需要一个职业人员来完成一些专业的操作，也可能由于当事人没有时间处理事务，而聘用代理人出面。

在软件设诈中，使用代理模式的意图也很多，比如因为安全原因，需要屏蔽客户端直接访问真实对象；或者在远程调用中，需要使用代理类处理远程方法调用的技术细节(如RMH);也可能是为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。


>以一个简单的示例来阐述使用代理模式实现延迟加载的方法及其意义。假设某客户端软件，有根据用户请求，去数据库查询数据的功能。在查询数据前，需要获得数据库连接，软件开启时，初始化系统的所有类，此时尝试获得数据库连接。当系统有大量的类似操作存在时(比如xml解析等),所有这些初始化操作的叠加，会使得系统的启动速度变得非常缓慢。为此，使用代理模式，使用代理类，封装对数据库查询中的初始化操作，当系统启动时，初始化这个代理类，而非真实的数据库查询类，而代理类什么都没有做，因此，它的构造是相当迅速的。
在系统启动时，将消耗资源最多的方法都使用代理模式分离，就可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时，再由代理类，单独去加载真实的数据库查询类，完成用户的请求
> 
> 主要思想是使用代理模式实现啊延迟加载,延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要使用的时候，才对它进行加载。使用代理模式的延迟加载是非常有意义的，首先，它可以在时间轴上分散系统压力，尤其在系统启动时，不必完成所有的初始化工作，从而加速启动时间；其次，对很多真实主题而言，在软件启动直到被关闭的整个过程中，可能根本不会被调用，初始化这些数据无疑是一种资源浪费。
> 
> 


## 享元模式

享元模式是设计模式中少数几个以提高系统性能为目的的模式之一。它的核心思想是：如果在一个系统中存在多个相同的对象，那么只需共享一份对象的拷贝，而不必为每一次使用都创建新的对象。在享元模式中，由于需要构造和维护这些可以共享的对象，因此，常常会出现一个工厂类，用于维护和创建对象。


享元模式对性能提升的主要帮助有两点：
1. 可以节省重复创建对象的开销，因为被享元模式维护的相同对象只会被创建一次，当创建对象比较耗时时，便可以节省大量时间。
2. 由于创建对象的数量减少，所以对系统内存的需求也减小，这将使得GC的压力也相应地降低，进而使得系统拥有一个更健康的内存结构和更快的反应速度。


享元模式的一个典型应用是在SAAS系统中。SAAS即Software As AService,是目前比较流行的一种软件应用模式。
以一个人事管理系统的SAAS软件为例，假设公司甲、乙、丙均为这个SAAS系统的用户，则定义每个公司为这套系统的一个租户。每个公司(租户)又各有100个员工。如果这些公司的所有员工都可以登录这套系统查看自己的收入情况，并且为了系统安全，每个公司租户)都拥有自己独立的数据库。为了使系统的设计最为合理，在这种情况下，便可以使用享元模式为每个租户分别提供王资查询的接口，而一个公司(租户)下的所有员工可以共享一个查询(因为一个租户下所有的员工数据都存放在一个数据库中，它们共享数据库连接)。这样，系统只需要3个享元实例，就足以应付300个员工的查询请求了。


## 装饰着模式

## 观察者模式

观察者模式是非常常用的一种设计模式。在软件系统中，当一个对象的行为依赖于另一个对象的状态时，观察者模式就相当有用。若不使用观察者模式提供的通用结构，而需要实现其类似的功能，则共能在另一个线程中不停监听对象所依赖的状态。在一个复杂系统中，可能会因此开启很多线程来实现这一功能，这将使系统的性能产生额外的负担。观察者模式的意义也就在此，它可以在单线程中，使某一对象，及时得知自身所依赖的状态的变化。

##  Value object模式

Value Object 模式提倡将一个对象的各个属性进行封装，将封装后的对象在网络中传递，从而使系统拥有更好的交互模型，并且减少网络通信数据，从而提高系统性能。