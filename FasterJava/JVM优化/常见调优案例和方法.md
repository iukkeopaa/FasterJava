## 将新对象预留在新生代

由于Full GC的成本要远远高于Minor GC,因此尽可能将对象分配在新生代是一项明
智的做法。虽然在大部分情况下，JVM会尝试在eden区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向老年代压缩。因此，在JVM参数调优中，可以为应用程序分配一个合理的新生代空间，以最大限度避免新对象直接进入老年代的情况。

## 大对象进入老年代

虽然在大部分情况下，将对象分配在新生代是合理的。但是，对于大对象，这种做法却是值得商榷的。因为大对象出现在新生代很可能扰乱新生代GC,并破坏新生代原有的对象结构。因为尝试在新生代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM不得不将新生代中的年轻对象挪到老年代。因为大对象占用空间多，所以，可能需要移动大量小的年轻对象进入老年代。这对GC来说是相当不利的。

基于以上原因，可以将大对象直接分配到老年代，保持新生代对象结构的完整性，以提高GC的效率。如果非常不幸的，一个大对象同时又是短命的对象，假设这种情况出现得比较频繁，那么对于GC来说将会是一场灾难。原本应该用于存放永久对象的老年代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，软件开发过程中，应该尽可能避免使用短命的大对象。

***注意***：短命的大对象对垃圾回收是一场灾难。目前没有一种特别好的回收方法处理这个问题。因此，开发人员应该尽量避免使用短命的大对象。

>可以使用参数-XX:PretenureSizeThreshold设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。

## 设置对象进入老年代的年龄

在堆中，每个对象都有自己的年龄。一般情况下，年轻对象存放在新生代，年老对象存放在老年代。为了做到这点，虚拟机为每个对象都维护一个年龄。

如果对象在eden区，经过一次GC后还存活，则被移动到survivior区中，对象年龄加1。以后，对象每经过一次GC依然存活的，则年龄再加1。当对象年龄达到阈值时，就移入老年代，成为老年对象。

这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold来设置，它的默认值是15。虽然-XX:MaxTenuringThreshold的值可能是15或者更大，但这不意味着新对象非要达到这个年龄才能进入老年代。事实上，对象实际进入老年代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数指定的是阈值年龄的最大值。即，实际晋升老年代年龄等于动态计算所得的年龄与-XX:MaxTenuringThreshold中较小的那个。

## 稳定和震荡的堆大小
一般来说，稳定的堆大小是对垃圾回收有利的。获得一个稳定的堆大小的方法是使-Xms和-Xmx的大小一致，即最大堆和最小堆(初始堆)一样。如果这样设置，系统在运行时，堆大小是恒定的，稳定的堆空间可以减少GC的次数。因此，很多服务端应用都会将最大堆和最小堆设置为相同的数值。

但是，一个不稳定的堆也并不是毫无用处。稳定的堆大小虽然可以减少GC次数，但同时也增加了每次GC的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，压缩堆空间，使GC应对一个较小的堆，可以加快单次GC的速度。基于这样的考虑，JVM还提供了两个参数用于压缩和扩展堆空间。

-XX:MinHeapFreeRatio:设置堆空间最小空闲比例，默认是40。当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间。

-XX:MaxHeapFreeRatio:设置堆空间的最大空闲比例，默认是70。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。


## 吞吐量优先

吞吐量优先的方案将会尽可能减少系统的执行垃圾回收的总时间，故可以考虑关注系统吞吐量的并行回收收集器。在拥有4GB内存和32核CPU的计算机上，进行吞吐量优先的优化，可以使用的参数如下

```java
java-Xmx3800m-Xms3800m-Xmn2g-xss128k-xx:+UseParallelGC-xx:ParallelGC-Threads=20-XX:+UseParallel0ldGC
```

- -Xmx3800m-Xms3800m:设置Java堆的最大值和初始值。为了避免堆内存的频繁震荡导致系统性能下降，让最小堆等于最大堆是一种比较常用的做法。假设将最小堆设置为最大堆的一半，即1900MB,那么JVM会尽可能在1900MB堆空间中运行，如果这样，它发生GC的可能性就会比较高。
- -Xss128k:减少线程栈的大小。这样可以使剩余的系统内存支持更多的线程。
- -Xmn2g:设置新生代大小。
- -XX:+UseParallelGC:新生代使用并行回收收集器。这是一个关注吞吐量的收集器，可以尽可能地减少GC时间。
- -XX:ParallelGCThreads:设置用于垃圾回收的线程数，通常情况下可以和CPU数量相等。但在CPU数量比较多的情况下，设置相对较小的数值也是合理的。
- -XX:+UseParallelOldGC:老年代也使用并行回收收集器。
## 使用大页案例

在Solaris系统中，JVM可以支持大页的使用。使用大的内存分页可以增强CPU的内存寻址能力，从而提升系统的性能。

```java
java -Xmx2506m-Xms2506m -Xmn1536m -xss128k -xx;+UseParallelGc -xx:Para-11elGCThreads=20-xX:+UseParallel01dGC-xx:LargePageSizeInBytes=256m
```
-XX:LargePageSizelnBytes:设置大页的大小。

## 降低停顿案例

为降低应用软件在垃圾回收时的停顿，首先考虑的是使用关注系统停顿的CMS回收器，其次，为了减少Full GC次数，应尽可能将对象预留在新生代，因为新生代Minor GC的成本远远小于老年代的Full GC。
```java
java-Xmx3550m-Xms3550m-Xmn2g-Xss128k-xx:ParallelGCThreads=20-xx:+UseConcMarkSweepGC -xX:+UseParNewGC-xx:SurvivorRatio=8 -xX:TargetSurvivor-Ratio=90 -XX:MaxTenuringThreshold=31
```

- -XX:ParallelGCThreads:设置20个线程进行垃圾回收。
- -XX:+UseParNewGC:新生代使用并行回收器。
- -XX:+UseConcMarkSweepGC:老年代使用CMS收集器降低停顿。
- -XX:SurvivorRatio:设置eden区和survivor区的比例为8:1。稍大的survivor空间可以提高在新生代回收生命周期较短的对象的可能性(如果survivor不够大，一些短命的对象可能直接进入老年代，这对系统是不利的)。
- -XX:TargetSurvivorRatio:设置survivor区的可使用率。这里设置为90%,则允许90%的survivor空间被使用。默认值是50%。故该设置提高了survivor区的使用率。当存放的对象超过这个百分比，则对象会向老年代压缩。因此，这个选项更有助于将对象留在新生代。
- -XX:MaxTenuringThreshold:设置年轻对象晋升到老年代的年龄。默认值是15次，也就是说对象经过15次Minor GC依然存活，则进入老年代。这里设置为31,即尽可能地将对象保存在新生代。
## JIT编译参数

JVM的JIT(Just-In-Time)编译器，可以在运行时将字节码编译成本地代码，从而提高函数的执行效率。-XX:CompileThreshold为JIT编译的阈值，当函数的调用次数超过-XX:CompileThreshold时，JIT就将字节码编译成本地机器码。在client模式下，-XX:CompileThreshold的取值是1500;在server模式下，取值是10000。JIT编译完成后，JVM便会用本地代码代替原来的字节码解释执行，因此，在系统的未来运行中，这些时间是可以被赚回来的。

JIT编译会花费一定的时间，为了能合理地设置JIT编译的阈值，可以使用-XX:+CITime打印出JIT编译的耗时，也可以使用-XX:+PrintCompilation打印出JIT编译的信息。


## 堆快照

在性能问题排查中，分析堆快照(Dump)是必不可少的一环。获得程序的堆快照文件有多种方法。在本小节中，介绍一种比较常用的取得堆快照文件的方法，即使用-XX:+HeapDumpOnOutOfMemoryError参数在程序发生OOM时，导出应用程序的当前堆快照。这是非常有用的一种方法，因为当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。

因此在OOM发生时，通过-XX:+HeapDumpOnOutOfMemoryError选项将当前的堆信息保存到文件中，对于排查当前问题是很有帮助的。通过参数-xX:HeapDumpPath可以指定堆快照的保存位置。

使用以下参数运行Java程序，可以在程序OOM时，导出堆信息到C盘的m.hprof文件中
```java
-Xmx10M -xX:+HeapDumpOnoutOfMemoryError -xX:HeapDumpPath=C:\m.hprof
```

## 错误处理
在系统发生OOM错误时，虚拟机在错误发生时运行一段第三方脚本。比如，当OOM发生时，重置系统：
```java
-XX:OnoutofMemoryError=c:\reset.bat
```

## 取得GC消息

要获取一段简要的GC信息，可以使用-verbose:gc或者-XX:+PrintGC。

